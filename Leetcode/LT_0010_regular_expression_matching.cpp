#include <iostream>
#include <vector>

using namespace std;


/*
 * 首先从题目上看，就很像一个DP的题，因为是个子问题 + 记录状态 + 多向选择。
 * 但是在思考上还是要多努力。
 *
 * 先说说自己开始的思维逻辑：
 * 假设有S 和 P，那么
 * s0 s1 s2 ...... sn
 * p0 p1 p2 ...... pm
 *
 * 当找到这么一组i j使得 p0......pj 可以按照规则匹配 s0......si
 * 那么当开始下一个pj+1 与 si+1的时候又可以开始进行重复行为。。。
 * 这里想法是，i j 同步前进，然后记录过去的子问题的状态，用来判断当前状态赋值。
 * 不对的原因是。。。如果pj+1遇到了*，
 * 那么pj != si+1 还好说。。。就false就行然后让j增加1再继续重复(其实这里已经没有同步了。。。只不过开始没意识到)
 * 如果pj == si+1呢？？i到底往前进几格？？相当于就得从此处开始进行一个循环，。，对前进不同的格子，进行不同的判断。。。
 * 这里相当于把从dp[i+1][j+1] 一直增加i直到s[i + ?] != p[j]这部分都设定成true。那么之后从p[j+2]开始才能有过去记录的判断。。
 * 然后如果p[j+2] 跟p[j] 遇到一样的问题，就也得继续循环。
 *
 * 不是说这样循环是错的。。而是说开始自己的想法太简单，不想循环。。想直接一路做完。。但是其实这么分析下来发现是不行的。。。就很呆。。。
 * 从Dp上看就知道了
 * 0 1 2 3 4 j
 * 1 ✔ ✖
 * 2     ✔ ✔
 * 3     ✔ ✖
 * 4     ✔ ✔
 * i         ✔ ︎
 *
 * 如果不去理会循环的话，或者只是就近判断几个。。。。。相当于只有对角线附近有值。。。
 * 总之就是缺了很多情况。。。那其实相当于并没有把所有子事件都给放进去。。。 这么一想。。其实就知道了。。想要填满这个二维数组。。还是得跑一个
 * n * m总次数的循环。。。把每个格子都填满。。才能对当前状态做之前的所有处理了。
 *
 * 还有反思其实很明显发现，之前的想法是 找到  p0......pj 可以按照规则匹配 s0......si 然后开始处理下一个。。就是已经钉死这个部分是匹配的了。。然后处理下一个。。
 * 其实这么个想法就不对。。明显后续很多地方都会是不匹配的false情况。其实就相当于是，在dp[i][j]ok我拿到了一个true。。然后后面的false呢？我是不是要填进去？？
 * 然后我填后面false的时候。。压根就没有用到dp[i][j]前面的情况。。因为是继续往后做处理的。再加上。。对于这种钉死的匹配状况。。完全可以因为后续的更多的'.' '*'加入
 * 让当前这个情况是false。。。
 * 就思维逻辑开始就是不对的。。想从对的出发永远找对的。。但是明明有错的。。还不知道去利用。去储存。。非要头铁一次走完。不走循环。。
 * 这么一想就知道了。要走循环。要利用false。。要用之前的状态的。。。哎。。。呆啊
 *
 * dp的开端没问题。。但是过程有了问题。。dp是用很多子事件的状态来定义当前状态，我这边开始妄想用当前1个状态，定义未来很多事件的状态。。就很迷。。
 * 还是要多想想才行。。。。。断片～～～～～
 * 再从brute-force想就知道了。。
 * brute-force就是把p从p0...pm取个遍。。然后每次都去做比较。看能不能匹配成功。。然后做后续处理。。
 * 过程中我们会发现。。随着j从0到m的增加。比对过程中。。明显发现短的匹配状态其实是可以用到的。。不用每次都重新做一遍。。。这才是dp出现的开端。
 * 然后我们要利用短的去定义现在的。。也就是后续的dp了。。。(写这么多反正都是反思。。能记住不能记住。。就看天命了！！！！！)
 *
 *
 * 好。现在回到正确的思路。怎么样在
 * s0.......si-1si
 * p0.......pj-1pj
 *
 * 注意流程是不断增加p的当前长度去匹配，更新dp表。。这样比较符合直观逻辑。。就是越来越长，然后长的可以利用短的记录的内容。就达到dp的逻辑了。
 * 这个状态去定义dp[i][j]是 true还是false
 *
 * 1、p[j] 属于 a - z。那么简单，只要判断 s[i] == s[j]就行 >> TM又来了。脑子秀逗了。。这俩相等又不代表dp[i][j]就是true了。。呆啊。。
 *    这里是要看dp[i - 1][j - 1]
 * 2、p[j] 是 '.'。也简单，直接就是true >> 跟1一个问题。。什么几十true了。这只代表这俩相等。。这部分是不是true还得看前面的表现。。
 *    所以这里也是看dp[i - 1][j - 1]
 * 3、p[j] 是* 那么就复杂了。
 * 这里，首先题目肯定保证了出现*，那么*前面一定有跟着字符。。(否则还得处理这个。。炸裂。。)
 *   a. 先看p[j - 1] == s[i] 如果是true 或者p[j - 1]是'.'
 *      那么我们让p[j - 1]* 代表两个也就是 s[i - 1] s[i] =>>>这里其实有点呆。。因为*的选择很多。。我给强制成2个了。还是没走出刚刚钉死true的想法。。。
 *      这个时候看dp[i-1][j-1]就行 >> 这个情况其实相当于是1或者2的情况。把pj当成一个非*的字符看就行
 *
 *      先是b下面漏了。。再回来a这边
 *      那么p[j - 1]*如果只是一个呢还得看dp[i][j-1]
 *
 *      那么p[j - 1]*如果是0个呢
 *      那么就看dp[i][j-2]了
 *
 *      那么p[j - 1]*超过2个呢 跟b中的一个道理。。你超过了。。不管前面是啥。。你p生成的字符串肯定比当前的s长了。。所以就也都是false了
 *      也是相当于在｜｜中加了很多个false。。不影响结果。。
 *      !!!!!不对。。。。b中因为p[j - 1] != s[i]才能那么下判断
 *      但是这里这俩相等，过程就不一样了。
 *      p[j]作为*可以代替成多个p[j-1]也即是多个s[i]。那么如果p[j - 1] == s[i - 1]呢，或者说 s[i - 1] == s[i]呢。
 *      那么此处s[i]就不是重点了。。反正s[i]可以被s[i-1]通过下面的p[j-1]*扩展来。
 *      那么这里就是dp[i][j]要看dp[i-1][j]因为s[i]不重要了。
 *      (其实这个我也是结果论了，先看到了错误情况。。再倒推。。这个情况咋处理。。。233333)
 *      例如 bbbb  >>>> bbbc(不存在)  >>>> bbbc >>>>  b  >>>> bbcb  >>>>>   b
 *            b*b        b*b               .*.     .*.        b*b      bbb*
 *      相当于 p[j - 1]* 成为了3个或以上(因为从小到大处理，只要处理到3个就行。4个没必要，因为往前退一格的dp状态是由往前退两格的dp状态作为一部分得到的)
 *      如果往前退一格是true，那么整个 或表达式就是true就没关系了。 如果是false。。那么往前退两格那个肯定也是false。
 *      那么这么推论的话，我们可以不判断s[i - 1] s[i] p[j - 1]三者的关系了。
 *      看上面几个例子。(第二个不存在。。因为前提 b c不相等。。就进不来这边的判断了)
 *      在下面的*后面多加一个，然后重新对齐。。是不是就相当于看dp[i - 1][j]了？？
 *      看第5个例子。最终dp[i][j]肯定是false对吧。那么dp[i - 1][j]是不是也是false？所以意思就是当s[i - 1] != s[i] 那就肯定是前面是false了。
 *      如果i-1是0呢？ 也就是到了最左边。那么直接看dp[0][j]是不是true就行。那么dp[0][j]在逻辑上会被我们当作base case先处理了。也是钉死的。
 *      综上：
 *      如果s[i - 1] 存在 且 s[i - 1] == s[i] 即p[j - 1] == s[i - 1] 可以将 dp[i - 1][j] 参与考虑
 *      如果s[i - 1] 存在 且 p[j - 1] == '.' 可以将dp[i - 1][j] 参与考虑
 *      如果s[i - 1] 存在 且 p[j - 1] != '.' 且 s[i - 1] != s[i] 那么 dp[i - 1][j]必然是false(例5)。所以是否参与考虑。不影响
 *      如果s[i - 1] 不存在，那么dp[i - 1][j] 就是dp[0][j] 应该要参与考虑
 *      综合一下就是。。我们不需要判断s[i - 1]的存在性 以及 相等情况。。直接把dp[i - 1][j]扔进去参与判断就行了！
 *
 *
 *      反思总结：
 *      对于第一个例子
 *      如果不加最后这个条件。。这个就是false了。但很明显这是true的。就因为我在处理的时候忽略了这种相等的可以由s[i - 1]扩展来的情况！！
 *      其实这个判定条件没想到用是因为脑海中还是钉死了dp[i-][j-1]之类是true。。其实不是的。。我们有很多子状况。如果一个子状况是false，那要么是
 *      匹配直接出错。。要么就是不够用。 其实这个条件就是忽略了不够用的问题！！ *可以让前面一个字符被用很多次。那么就可以在处理的时候。往前看看被用多次后会是什么情况。
 *      然后根据dp的顺序。如果每次都是从小到大的去处理，通过前面已经记录的状态，就不用说写个循环往前看所有直到0或者不同为止了。。因为从小到大的过程
 *      已经把dp中序号小的部分的情况都拉满了，直接用就行。这也是dp带来的优势了。
 *
 *   b. 如果不等
 *      那么我们让p[j - 1]*代表0个。
 *      这个时候要看dp[i][j - 2]因为pj-1pj相当于都没了。。。
 *
 *      还可以让p[j - 1]*代表1个。
 *      这个时候看dp[i][j-1]因为pj相当于没用了。
 *
 *      !!!这里还是漏了。。。
 *      如果p[j - 1]*代表2个呢？代表3个呢？？。。。。emmm等会想一下的。。
 *      好像没意义了。。肯定就是false了。。因为不论d[i-1][j-1]啥状态。。上面只多了一个si下面多一个pj 代替 pj-1还行。。再多。。明显就不匹配了。
 *      也就是说不用考虑这个情况，当于是 {某个不知true还是false的子状态} || false || false || false。。。毕竟后面的所有都是false了
 *
 *
 * 这里可以看到一堆 -1在。再加上我们的base case就是最基础还没定下来。。
 * 比如
 * P a
 * S a
 *
 * 这里用dp[0][0]？？ 那我dp[-1][-1]哪里来，是吧？所以很明显，我们需要在原始的从0开始的index前，再加一圈。来保证往前找的时候是ok的
 * 对于-2不用担心。。遇到-2就代表前面肯定有一个字符了。。肯定不会越界的。
 *
 * 但是这样处理就是所有东西都要 +1 或者-1去弄。。麻烦。。
 * 或者就是单独把base case先处理了。
 * 这里好像不能单独处理base case。。。因为-2在。。过不去。。很烦。。除非处理两列。。那也忒麻烦了。。还是加一圈吧
 *
 * S = ab
 * P = ..
 *
 *   0 1 2
 * 0
 * 1
 * 2
 * 本来开始要看00。但是00没得看，因为没有-1 -1。
 * 就算把 0行0列都单独处理了。。那么那个-2，对于1列1行。。我们又不能做了。。所以如下，多弄出一行一列也就是某个为空的状态来看结果。
 *
 *   0 1 2 3   J
 * 0 T F   F
 * 1 F
 * 2 F
 * 3 F
 *
 * S
 *
 * 对于 [2][0]需要看2是不是*，如果是*那就都是T否则就是F
 * 同样类比到[4][0] [6][0] 只要是后续都带*了就要看两位前有没有带*。也就是看[i - 2][0]的状况
 *
 *
 */


/*
 * 上面分析了很长，很多。其实代码里很多可以省去的，也不影响结果。。。但是毕竟想把所有情况写出来。这样子自己看着清晰点
 * 也明白具体都有哪些个情况。再次写起来代码也会快一点。
 */

class Solution {
public:
    bool isMatch(string s, string p) {
        int n = s.length();
        int m = p.length();

        vector<vector<bool>> dp(n + 1, vector<bool>(m + 1, false));
        dp[0][0] = true;
        for (int j = 2; j <= m; j++) {
            if (p[j - 1] == '*') {
                dp[0][j] = dp[0][j - 2];
            }
        }

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (p[j - 1] == s[i - 1] || p[j - 1] == '.') {
                    dp[i][j] = dp[i - 1][j - 1];
                }
                else if (p[j - 1] == '*') {
                    if (p[j - 2] == s[i - 1] || p[j - 2] == '.') {
                        dp[i][j] = dp[i][j - 1] || dp[i][j - 2] || dp[i - 1][j - 1] || dp[i - 1][j];
                    }
                    else {
                        dp[i][j] = dp[i][j - 2] || dp[i][j - 1];
                    }
                }
            }
        }
        return dp[n][m];


    }
};



int main() {
    return 0;
}