#include <iostream>
#include <vector>
#include <unordered_set>

using namespace std;


class Solution {
public:
    /*
     * 这里跟无重复的全排列区别就在于。。有重复的数字。需要去重。。
     *
     * 1、先说开始的错误想法
     * 开始我想着把原数组给排序一下。这样子后续可以通过连续查找，把相同的给去掉。就不会重复了。。。
     * 比如 0 1 0 9。排成 0 0 1 9然后开始找全排列。
     * 但是我忽略了一个问题。。
     * 比如这个排列。当我按照逻辑排到了
     * 9 0 1 0后。首先固定了9。然后固定了0。 ok这时候。。其实我不应该把后面那个0拿过来的。。但是根据逻辑。。我就拿过来了。。导致我的结果多了重复的部分。。
     * 其实这里就是忽略了一个问题就是。。当在过程中交换的时候。。就把原来排好序的部分给换掉了。。(至少在交接固定某个index的时候)然后就会出现重复的数字中间多了个别的数字
     * 然后就炸了。。。
     *
     *
     * 所以基本想法就是。。在某个index位置开始塞数的时候。用个set存一下。。看哪些用过。。用过的就不能再用了。。
     * 事实上这个代码也跑的通。速度也还行。。。但是。。。
     * 用的空间太多了。。。每一个index都要维护一个set。或者用定长vector也行。。意思一样。。
     * 就浪费了很多空间。。。
     *
     * 然后就开始研究怎么能不浪费空间。。。然后我就不会了。。。。(TMD又不会了。。为了省个空间哎。。我还是太弱了。。。)
     * 然后就。。看看别人咋省的空间。。学一下。。23333
     *
     * 其实就是这里的9 0 1 0。。如何在固定index = 1这个位置时。。避免重复呢？？ 方法2写了一下。。还有自己的解释。。哎。。
     */
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        backtracking(nums, 0);
        return res;
    }

private:
    vector<vector<int>> res;
    void backtracking(vector<int>& nums, int idx) {
        if (idx == nums.size()) {
            res.push_back(nums);
        }
        else {
            unordered_set<int> used;
            for (int i = idx; i < nums.size(); i++) {
                if (used.count(nums[i])) {
                    continue;
                }
                else {
                    used.insert(nums[i]);
                    swap(nums[i], nums[idx]);
                    backtracking(nums, idx + 1);
                    swap(nums[i], nums[idx]);
                }
            }
        }
    }


public:
    /*
     * 这里写完后我发现。。问题还是因为。。思维停滞在了46题后的情况。。
     * 46那种刚好swap后backtracking把所有情况都包含进去了的结果。对这个题会造成很大的误导作用。
     *
     * 其实 从正规逻辑上来说。我们应该怎么做？？
     * 对于 1 2 3 4 找全排列。我们是：
     * [] [] [] []
     * 首先找到4个位置
     * 然后第一个位置在1 2 3 4 选一个。 比如选了3
     * 然后第二个位置在1 2 4中选一个， 比如选了4
     * 以此类推。最终得到一个排列。
     *
     * 只不过46那种逻辑刚好做完了。
     * 所以对于46 47。当回归到正常的backtracking后又是怎么样呢？？ 这里就有之前的一个backtracking的问题了。在做combination sum的时候
     * 我们是可以从当前的idx往下找而不是从0开始找。这里也对46 47造成了迷惑。其实也是自己么想明白。
     * 39 40别人要的是组合。 {2 3} {3 2}是一个结果。当然不能重复了。所以从一个数只能往后找不能往前找。。
     * 但这里是排列。。这俩是不一样的。。可以往前找的。。(想到这一步我一下子就豁然开朗了。。就知道自己哪里弄的不对了。。回想起了数独。。数独就是从0开始找的。。然后判断是否能填。。所以还是做的少了。理解不够)
     *
     * 那么这里就很明显了。比如我们处理 0 1 0 9 0这样子的组合。为了去重，排序肯定是有必要的，毕竟从我们认为的构造角度来说。我们在第一个位置放了0就不会再放0了。那就用个排序就ok了。
     * 首先得到0 0 0 1 9
     *
     * 然后呢 我们开始找5个位置
     * [] [] [] [] []
     * 第一个位置放0，第二个位置0 ..... 得到了[0] [0] [0] [1] [9]
     * 好。问题来了。怎么选。。人为去看当然很简单，作为程序怎么看？
     *
     * 1、首先判断当前找的位置，也就是构造的结果够不够5(原始的size)。够了就输出，这是一个结果。
     * 2、不够的话，开始找数，这边就是重点了：
     *      对于当前这个位置，我们从 0 0 0 1 9这5个数中去找，首先我们不能用已经用过了的。比如说第一次我们选的结果是 [0] 0 0 1 9
     *      我们选了第三个0放在第一个位置构成了 [0] [] [] [] []
     *      那么对于第二个位置的时候，我们怎么判断？当然就是判断index = 2是否选过。如果选过了。那就是前面用了。就可以跳过了。
     *
     *      到目前为止，这个逻辑可以用于46题，没问题。因为就这么选下去，最终会选够所有的。(毕竟for循环判断是否选过加穷举啊！！！！)
     *      但是这里还有去重
     *      那么问题就来了
     *      当我们在第一个位置选过第一个0。得到这个状态
     *      [0] 0 0 1 9
     *      [0] [x] [x] [x] [x]
     *      (假设后面都选了。。先不管。就说开始第一个位置的事情。)
     *      下一步，我们肯定是不能再选0了对不对，那我们怎么跳过？？(这里我开始呆了。。干嘛选第三个0。。。。程序不都从index = 0开始么。。好蠢233333强行给自己加戏。。)
     *      当我们处理完这一堆的时候
     *      我们会把 visited[0] (这个是指index = 0的位置，不是数字0) 置为false。因为要换下一个了。这个就肯定是false了没用到。
     *      ok这个时候index来到了1。我们又看到了一个0。从人为的角度，我们知道。这个0不能选。那么通过上面的条件，如何告知程序呢？
     *
     *      直接 nums[index] == nums[index - 1] 就判死刑么？？不行
     *      如果这样的话，我们如何得到[0][0] [x][x][x]这种情况呢？？那还差了啥？区别在哪？
     *      发现区别就是。。我们用第二个0的时候。第一个0已经用了。所以这个意思是，我现在找的这个0，不是要往第一个位置放数的0，是第二个位置了。(有点绕)
     *      那就可以放了。也就是所谓的
     *      当我们在处理 [0] [] [] [] []
     *      这个情况时候。我们可以在第二个位置放0。因为现在处理的是第二个位置。。所以说白了。这里用一个 !visited[i - 1](我把顺序换了回来，逻辑上更容易理解)
     *      发现，我虽然是跟前面重复了，但是。我这并不是在上一个位置取下一个重复的数，我已经到下一个位置了，没问题的。
     *
     *      总之这个就是很绕。。绕的飞起。。我就先这么理解一下把。。先不push上去了。。为了之后再看看。。再想想。。TMD好复杂呀。。。
     *
     *      总结了一个小tip就是。。本位置如果发现重复数则跳过。除非该重复数跟着前面的重复数一起用了。也即是按照程序从0 到 n执行顺序来看。除非是这个重复数前面被用了，到自己这里就是下一个位置了
     *      否则就是如果前面就没用过。那么到自己这里就是当前位置，并且重复了。就不能用了。
     *      所以把 !visited[i - 1]当成当前重复数所在的处理位置判断也行(当前位置还是下一位置或者叫 上一位置还是当前位置，总归就是错开了一个位置 2333用一个判断搞定。。真是，牛皮！！！)
     *
     *
     *
     *
     */
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<int> cur;
        vector<bool> visited(nums.size(), false);
        backtracking(nums, cur, visited);
        return res;
    }

private:
    vector<vector<int>> res;
    void backtracking(vector<int>& nums, vector<int>& cur, vector<bool>& visited) {
        if (cur.size() == nums.size()) {
            res.push_back(cur);
        }
        else {
            for (int i = 0; i < nums.size(); i++) {
                if (visited[i]) {
                    continue;
                }
                // if (i && !visited[i - 1] && nums[i] == nums[i - 1])
                if (i && nums[i] == nums[i - 1] && !visited[i - 1]) {
                    continue;
                }
                visited[i] = true;
                cur.push_back(nums[i]);
                backtracking(nums, cur, visited);
                cur.pop_back();
                visited[i] = false;
            }
        }

    }
};