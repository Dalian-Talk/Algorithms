#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    //这题没啥说的。。记住下面写的找下一个排列的规矩就行了。。哎。又得记住 头疼呵。。。
    /*
     * 真的就是。。记住规则了。。。
     * 1、从右往左找持续递增的序列
     * 2、再从递增的最左边往右找，找到最后一个比递增序列左边的数字大的数。也即是找到最小的比递增序列左边数字大的数。
     * 3、交换这两个数
     * 4、将整个递增序列翻转。
     * 到实际例子就是
     * 1 3 4 6 5 2
     *
     * 1、找到6
     * 2、比4大的最小的数(最后一个比4大的数)，即5
     * 3、交换 =>> 1 3 5 6 4 2
     * 4、翻转递增序列 =>> 1 3 5 2 4 6
     *
     * corner case的处理
     * 1、假设是 3 2 1这种。这是最大的了。下一个是1 2 3怎么办？
     *    那我们要看怎么找的。
     *    如果逻辑是从1出发，看前面一个数是不是比当前的数大。那么最终i停下的位置，两个情况。 i == 0 或者 nums[i] > nums[i - 1]
     *    对于i == 0，那么就是 3 2 1这种情况了。
     *    对于nums[i] > nums[i - 1]就是 1 3 2这种情况了。
     *    也就是说这么找的话，最终i会停在递增序列的最大的数那边。是没问题的。
     *
     *    然后需要判断 i == 0
     *    如果i == 0那么就不用交换什么了。直接翻转
     *    如果是另一种，就要开始找了。
     * 2、从i出发往右找到比 i - 1大的最小的那个数要怎么处理？？如果遇到 1 2 3怎么办？
     *    找的逻辑是
     *    j从i出发，直到找到一个比 i - 1小的数为止，那么j - 1的位置就是我们要的数
     *    a、如果j走到了底，即 j == n >> 1 2 3，j从3出发后，走到了3后面，那么没问题 3就是我们要的，即 j - 1是ok的
     *    b、如果j是正常的走到了中间，比如 1 3 4 6 5 2， j走到了2，那么5是我们要的。也就是j - 1是ok的
     *
     *    所以综上，对于找到最小的比i - 1大的数可以直接使用j - 1，不论j是在数组中间，还是越界了。
     */
    void nextPermutation(vector<int>& nums) {
        int n = nums.size();
        int i = n - 1;
        while (i > 0 && nums[i] <= nums[i - 1]) {
            i--;
        }
        if (i != 0) {
            int j = i;
            // 这里就是上面注释中的2部分。
            while (j < n && nums[j] > nums[i - 1]) {
                j++;
            }
            //出来后直接用j-1的数就行了。不会有out of index的问题。(a,b两个情况都分析了)。
            swap(nums[i - 1], nums[j - 1]);
        }
        reverse(nums.begin() + i, nums.end());
    }
};