#include <iostream>
#include <vector>

using namespace std;



class Solution {
public:
    /*
     * 只能说开始自己写东西还是太急躁了。这个题分析情况的时候没分析清楚就动手了。。这边把分析过程重新好好写写吧。。哎
     *
     * 从本质上来讲。这个题和一般的二分区别只是在于。。多了点翻转。所以导致在正常改变left right的时候多了些判断。。
     * 只不过开始的时候。脑子有点秀逗。言归正传。。
     *
     * 对于一个数组(或者运行到中间的某一部分数组)
     * a0 a1 a2 a3 a4 a5 a6 a7
     *
     * 那么这部分就是 left=0，right=7，mid=3
     * 分情况讨论
     * 1、a3 == target。简单返回就是了。。
     * 2、a3 < target。
     *   正常有序肯定就直接left = mid + 1了呗。但是这里有好多种情况来决定要怎么动。有如下几种
     *   1)[a0 a1 a2]         [a3 a4 a5 a6 a7]
     *   2)[a0 a1]            [a2 a3 a4 a5 a6 a7]
     *
     *   3)[a0 a1 a2 a3]      [a4 a5 a6 a7]
     *   4)[a0 a1 a2 a3 a4]   [a5 a6 a7]
     *   左边就是大的那部分，右边就是小的那部分。只是把可能的几种类型全部列了出来。
     *   这几种类型的两大类型就是 1) 2) a3在右半区， 3) 4) a3在左半区。
     *   ！！！这里才是问题所在我开始总想着用left right的大小关系去跟target比然后去处理所有东西。但是总是漏了情况。。
     *   后来瞅了眼以前答案，发现用了mid，也就是这里的a3来区分。我就想到估计是首先看mid在左半区还是右半区，然后再来决定所有情况了。。先说这种mid处理方式吧
     *
     *   区分a3在右还是在左比较容易：
     *   如果a3 < left 那么就很明显在右
     *   反之在左
     *   或者a3 > right那么很明显在左
     *   反之在右
     *
     *
     *   如果1)2)，即a3在右半区：
     *   那么a3 < a0(left) >> 因为右半区的都比左半区的小。并且left对应的是左半区最小的。所以跟left比就知道a3是在右半区还是左半区
     *   这种情况。比a3大的可以在左边，也可以在右边。这个时候开始区分处理
     *   如果 right比 target还小，那么右半区就没有意义了，
     *   right = mid - 1
     *   反之
     *   left = mid + 1
     *
     *   如果3)4)，即a3在左半区：
     *   那么大的就肯定在右边了。也就是
     *   left = mid + 1
     *
     * 3、a3 > target
     *   这部分处理和2类似，可以继续沿用2种的左右半区区分，也可以换一边的逻辑。毕竟两边都行不是
     *   3)4)左半区
     *   a3 > right(跟2左了个区分 23333，结果是一样的)
     *
     *   这种情况就是要区分。因为比a3小的可以在两部分
     *   如果 left 比target 还大，那么左半区就没必要了。右边就行
     *   left = mid + 1
     *   反之
     *   right = mid - 1
     *   (跟右边比也是一样的)
     *
     *   1)2)右半区
     *   a3 < right
     *   那么小的肯定在左边了 right = mid - 1就行
     *
     * 所以综上就是。。主要是要多处理一些mid在左半区还是右半区的行为。。。开始没处理这个就一直在错。。。
     *
     *
     * 这里来纠正一下为啥开始自己直接用left和right没做对。首先要明确的一点是。
     * 无论当前是在正常的sorted部分还是左右半区都有的部分
     * left对应的肯定是左半区最小的
     * right对应的肯定是右半区最大的。。
     * 所以我开始的想法就是。
     * 当 a3 < target，我们需要找更大的。怎么找？？那么就看右半区最大那个。。如果这个都没target大。。就没必要去右边找了。。但是这里问题就有了。。那会没注意到。现在想到了
     * 如果当前数组是这样的
     * [a0 a1 a2 a3 a4] [a5 a6 a7]
     * a7可以比target小，这个没关系。。但是a4比target大啊。。。如果按照上面那个处理。。a4就被删了。。没了。。
     * 这里问题就在于。。right是右半区最大的没错。。但是他不是当前mid右边最大的。。这么比较就少了情况了。。。
     * 那么这个时候能不能通过检查mid右边还有没有数来看呢？？感觉也可以噢。去试试
     * 那这个处理。。相当于就是判断mid在不在左半区了。。。
     * 所以实际结果还是要看mid在不在某个半区。。。emmm。当然可以先试验一下刚刚说的方法。。
     *
     *
     *
     * ！！！！(反正试验失败了。。。干！！！直接用left right 加上一个mid + 1的处理。。好像不行。。或者我没写对？？)
     * 总之。这个题就是要领会到上面那4个分区情况。。然后分情况处理就行了。。
     * 重点是要想到a3在哪个分区的问题。。否则就漏了。。哎。。。开始一直没注意到a3的存在对结果的影响。。单纯在用left right处理。。有点呆呵。。
     * 其实就是
     * 本来要往左找。但是为啥不能往左找了？？是因为什么情况导致了往右找？？这个情况特殊在哪？？
     * 最后分析得知 特殊的就是这个a3的位置。23333
     *
     *
     */
    int search(vector<int>& nums, int target) {
        int n = nums.size();
        int left = 0;
        int right = n - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] == target) {
                return mid;
            }
            else if (nums[mid] < target) {
                if (nums[mid] > nums[right]) {
                    left = mid + 1;
                }
                else {
                    if (nums[right] < target) {
                        right = mid - 1;
                    }
                    else {
                        left = mid + 1;
                    }
                }
            }
            else {
                if (nums[mid] < nums[left]) {
                    right = mid - 1;
                }
                else {
                    if (nums[left] > target) {
                        left = mid + 1;
                    }
                    else {
                        right = mid - 1;
                    }
                }
            }
        }
        return -1;
    }
};