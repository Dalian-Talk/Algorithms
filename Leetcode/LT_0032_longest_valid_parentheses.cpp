#include <iostream>
#include <vector>
#include <stack>

using namespace std;


class Solution {
public:
    /*
     * 先把自己想错的这个写在这里。。。这边我傻愣愣的就以为，只要左括号足够多。。就可以让这段括号是合法的。。。
     * 然后就被这个测试数据给无情的打脸了。。
     *
     * ()(()
     * 。。。。很明显左括号够多。。但是最长的合法的括号对也就只有两个单独的 () ()所以长度是2。不是4。。。。
     * 还是太想当然了额。。年轻了。。干。。。
     */

    int longestValidParentheses(string s) {
        int left = 0;
        int right = 0;
        int res = 0;
        for (auto c : s) {
            if (c == '(') {
                left++;
            }
            else if (left != 0) {
                right++;
                if (right > left) {
                    res = max(res, left * 2);
                    left = 0;
                }
            }
        }
        res = max(res, min(right, left) * 2);
        return res;
    }

    /*
     * 其实开始的想法和dp也很类似。就是找右括号，找到的时候跟左括号进行对比。只不过思维有点钝了，，加上开始的想法太天真。。哎。。
     * 但是当你找到一个右括号时，并不知道这个右括号是否能跟之前某个左括号合成一对括号。或者一系列合法的括号
     * 比如
     * ()
     * 这种就很简单，我们知道这是一对合法的。这是最基础的部分。
     * (())  ((()))
     * 这种类型的括号也是合法的，但是对于某个右括号，没法很简单的直接处理左边一个是不是左括号。
     * 那么这个时候就要看。对于当前这个右括号。能不能在左边找到一个合法的左括号。。并且能够包住中间的括号。如果中间不是合法的，那外面那个也不可能合法，就相当于没有长度了。
     *
     * 再有就是跟心目中之前dp的区别。。dp之前总是某个点存的就是最终结果，然后最后取最后dp[n]就能得到结果。。这里是不行的。。因为
     * 如果dp[i]代表 到i为止最长的合法括号对，那我们就无法进行上面那种 外面包里面，然后里面是否合法的判断了。。因为都是有存最后真实长度的，就没有0这个长度了。。
     * 所以只能让dp[i]代表，到i为止，以i作为终点的合法括号对长度，这样子相当于是i一定要在里面，作为i存在的往前找看能不能找到合法括号对的长度。
     * 这个是相当于一个局部性的以当前右括号作为终点的，合法括号对(长度可以是0，也就是没有合法的)。
     *
     * 所以说是dp。。。emm也算吧。毕竟他也记录了之前每个以右括号作为终点的i位置的局部合法括号对长度。
     * 然后通过额外的判断去看这些局部的能不能连到一起。。
     *
     * 所以总结下来，重点就是。碰到右括号，要看这个右括号能不能和之前的某个左括号对起来，包括简单的()以及复杂的带包含的(())。情况分开处理就行。。
     * 说是dp。。其实也就是存了之前所有情况。可以用很多方式去做，不光是dp。。只要能存情况，然后判断能否连起来就是。
     *
     * 上面的方法1之所以不对，就是因为，只是通过右括号和左括号的个数进行对比，知道了目前的长度，但是并没有判断目前这个和之前的能否合法的连接在一起。
     * 就是少了判断的这一步。
     * 用dp的方法就可以把这一步加上了。多了一层判断就能搞定。
     */
    int longestValidParentheses1(string s) {
        int res = 0;
        int len = s.length();
        vector<int> dp(len, 0);
        for (int i = 1; i < len; i++) {
            if (s[i] == ')') {
                // ()简单的情况
                if (s[i - 1] == '(') {
                    dp[i] = i >= 2? dp[i - 2] + 2 : 2;
                }
                    // (())复杂的情况
                else {
                    // 前一个右括号存在合法的结果，那么当前这个可以判断是否能找到合法的左括号来包进去
                    if (dp[i - 1] > 0) {
                        int idx = i - dp[i - 1] - 1;
                        if (idx >= 0 && s[idx] == '(') {
                            // 这里后面的 + 就是把当前处理到的idx为(的前面给连起来了，是0就是0不是0就是正常有合法的可以连起来。
                            dp[i] = dp[i - 1] + 2 + (idx > 0? dp[idx - 1] : 0);
                        }
                    }
                }
                res = max(res, dp[i]);
            }
        }
        return res;
    }
    /*
     * 所以经过上面的代码。。我们发现。。这里所谓的dp，其实就是我们从左到右一个一个处理。处理完 往前看看那边能不能跟前面连起来。能连就连，不连就自己的就行
     * 所以其实不需要特别的把他想成dp。
     * 当然这里对于遇到右括号的两个情况 => ()   (())
     * 其实也是相当于dp的一个多个选择部分？？然后后面跟前面连起来的处理，又是子事件的iterative处理？？
     * 就很。。哎。。很多时候想不到dp的做法。。很气呵。。
     * 反正自己脑补的dp就是
     * 1、最XXX啥的问题
     * 2、一步一步走来的。。或者有子事件需要记录情况的
     * 3、每次往下走，都有一堆选择。。要根据选择来决定这一步怎么走最好。。然后还要跟之前的联系起来。。
     * 这种。。就考虑考虑dp看看呗？？ 自我催眠就是=》》》》》 记录以前的结果、这个结果在后面做选择的时候要用到、一堆选择找最XXX的。。233333差不多这么记住先把
     *
     */



    //用栈去处理括号这种类似的两两匹配啥的。。也是一个好办法
    /*
     * 1、遇到左括号，放进栈
     * 2、遇到右括号，看栈顶是不是左括号，是的话就可以左括号出栈。。因为这部分是合法的了
     * 问题就是后续处理了。。怎么跟前面的连起来。比如
     * ()(())
     * 处理完第一对后。。栈就空了。如果这时候记录一个2。 ok先这么做做看
     * 然后处理完后面一对后，我们得到了4。然后4 + 2 = 6 完美是吧？
     * 那么看这个例子
     * ()(()
     * 咋整？
     * 2 + 0 + 2？？就炸了
     * 还是处理完第一对后，长度是2
     * 然后处理完第二对后，长度也是2，这个时候栈里面还有个(，也就是说这个长度2。。并不能连到前面那个长度2。这个时候就知道ok不能连了。各是各的
     * 那就相当于我们碰到一个 左括号，或者是到终点了，看看栈里面还有左括号没，然后来决定能不能连？？ 也不对！！！
     * 看这个例子
     * (()()
     * 处理完第一对括号，得到了2
     * 然后处理完第二对后，又是一个2
     * 那么我们应该得到4才对。。。但是按照上面的结论。。就得不到4了。。因为这个例子中栈的情况和 ()(()是一样的。。
     * 所以我们可以直到。不能简单的做判断来加法去相连。。会出很多问题。。
     * 但是根据最后两个相似的栈的情况。如果我们存的是字符对应的index呢？？？我们是不是立马就知道了前一个是4后一个是2呢？？
     * 原因就是本来只存字符本身，我们是没有顺序位置概念的。但是一旦加上了index，我们就有了顺序、位置的概念。在处理上就会带有更多的逻辑。。
     * (当然写这么多分析都是屁话。。我要不是看到了之前的答案注释。。我压根也想不起来。。就TM很气)
     *
     * 这种存了index后我们发现。。比如 (()()
     * 处理完第一对后，栈里面剩的是0 => '('，此时i在2，长度为2
     * 处理完第二对后，栈里面剩的还是0 => '('，此时i在4，长度为4
     * 是不是很刚好？
     * 这就是用最后一次找不到匹配的。。剩下的index放在栈里，然后通过当前的i来每次算长度，就知道最长是多少了。相当于每次遇到一个右括号都要来一次判断。
     * 然后用这个右括号去跟栈顶可能存在的左括号进行消去。当消去这部分后，再根据剩余栈顶的index，就知道从当前栈顶到这个右括号i为止合法的括号对有多长了。
     * 简而言之就是用栈进行一对一对的消去，消去后算目前消去了多长即可。。。23333
     *
     *
     */

    /*
     * 这段代码的处理比较丑陋。核心思想就是。当遇到一个右括号，看栈顶对应的是不是左括号。是左括号就ok，pop出来，然后用之后的栈顶来计算当前长度，存储最终值
     * 如果栈顶不是左括号。。那相当于这个右括号已经没用了。就把i放进去当一个标志位吧。方便后面的计算。
     *
     * 由于加了-1在栈顶来处理 ()(())整个字符串都正确的情况，所以不用担心stack会空。
     * 但是在结尾还需要再用s.length()再做一次比较。。否则就缺了这种整个字符串都合法的情况了。(结果发现并不需要好吧。。在else里面都处理过了。。呆啊！！！！)
     */
    int longestValidParentheses2(string s) {
        int len = s.length();
        int res = 0;
        stack<int> s_idx; // -1是因为如果开头就有合法括号对。。那不就没有前面的index了么。。所以把那个不存在的前面的-1index给放进去。
        s_idx.push(-1);
        for (int i = 0; i < len; i++) {
            if (s[i] == '(') {
                s_idx.push(i);
            }
            else {
                int cur = s_idx.top();
                if (cur >= 0 && s[cur] == '(') {
                    s_idx.pop();
                    res = max(res, i - s_idx.top());
                }
                else {
                    s_idx.push(i);
                }
            }
        }
        // res = max(res, len - s_idx.top() - 1);
        return res;
    }


    /*
     * 方法4算是我第一个错误方法的延伸+改正了。。
     * 第一个错误点在于，我只关注了左括号比右括号多，我就可以去凑对。。然后 ()(()就把我给毙掉了，因为这种情况。。左过多了。。右不够多，然后你并不知道
     * 左到底是否放在合法的地方。。所以就错了。。
     *
     * 真实情况是。 对于只有小括号()的字符串，如果在遍历中 找到 左==右，那肯定没问题，这段必然是合法的。比如((()))  ()()()这都是没问题的。
     * 那这么找。。很明显。。 ()(()()我们就找不到这个最终结果4了。。因为 从 () !(()() 第二部分开始，，左就比右多了。。但是我们不知道左比右多了多少。
     * 这时如果我们从右往左看。。是不是就知道了。。噢原来左括号多了一个。。。
     *
     *
     * 所以这里的思维逻辑就是。
     * 1、只要 左 == 右，这个字符串就一定是ok的(局部！！！)
     * 2、如果存在左 > 右，那么就是有个左括号多了，我们从右往左看就行
     * 3、如果存在左 < 右，那么就是有个右括号多了，我们从左往右看就行。
     *
     * 但是在处理的开始我们不知道左右谁多。。所以从左往右，从右往走各走一次就行。。。
     * 这个方法，说实话，才是真正用到了这种只有小括号对的已知条件。。很有技巧性。。(然而我记不住，，我也想不到 233333)
     *
     *
     */

    /*
     * 充分利用了特点好吧。。很巧。。能想到算我牛皮。。想不到。。那就用上面的处理方式吧。。23333
     * dp那个比较好能想到 记住
     * stack那个比较容易忘记index去做而单纯的进行加法和归零，容易出错。
     * 下面这个左到右、右到左。就牛皮点了 23333。特性 特性！！
     */
    int longestValidParentheses3(string s) {
        int res = 0;
        int left = 0;
        int right = 0;
        for (auto c : s) {
            if (c == '(') {
                left++;
            }
            else {
                right++;
            }
            if (left == right) {
                res = max(res, left * 2);
            }
            if (left < right) {
                left = right = 0;
            }
        }
        left = right = 0;
        reverse(s.begin(), s.end());
        for (auto c : s) {
            if (c == '(') {
                left++;
            }
            else {
                right++;
            }
            if (left == right) {
                res = max(res, left * 2);
            }
            if (left > right) {
                left = right = 0;
            }
        }
        return res;
    }
};