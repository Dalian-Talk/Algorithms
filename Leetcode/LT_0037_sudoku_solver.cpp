#include <iostream>
#include <vector>

using namespace std;


class Solution {
public:
    void solveSudoku(vector<vector<char>>& board) {
        init_check(board);
        dfs(board, 0, 0);
    }


    //这里开始我在那边走四个方向。。差点没把栈给玩没了。。
    //然后走两个方向。。
    //结果发现走一个方向就行。。其实没差。。所以走一个就走一个方向吧。。反正数独都是一个一个填的呗。。2333
    //先试试往右往下能不能走完了。。23333
    //事实证明不能一次走两个方向。。分析一会放本地写一堆去。。。

    /*
     * 写下分析。。。
     * 1、首先最傻逼的。。我们初始化。。给那边从0开始放。。我干。。我真是服了我自己。。
     * 2、我TM开始还走的四向。。简直了。。过去回来过去回来。。这明显就是对数独的没理解导致的。。数独本来就是填好一个数，看下一个，直到走到一个不管什么
     * 都填不了得。。再倒回去重新来。。就跟八皇后一样。。典型的backtracking。。。
     * 3、我开始在那边走两个方向。。而不是经典的单向backtracking。我也不知道为啥。。我总觉得。。就那么走下去就行了。。不能双向的错误原因是
     *
     * 用一个小的3 * 3 的来描述
     * a0 a1 a2
     * a3 a4 a5
     * a6 a7 a8
     *
     * 如果双向走。假设先下后右。。。
     * 我们获得了一个满足数独要求的 a0 a3 a6
     * 和一个满足数独要求的 a6 a7 a8
     * 看起来很完美对吧？
     * 但如果a6 a7 a8不是最终结果呢？？
     * 我们在填a1 a2 a4 a5的时候是不是就炸了？？
     * 然后这个时候我们发现。。我们不能再回去修改a6 a7 a8了。。因为他们三个提前走完了。。这辈子都不会再被修改了。。。这样子就错了。。
     * 其实这个问题就是。。当我们解决a7 a8的时候 并不是从a4 a5这条路来的。而是从0 - 3 - 6 - 7 - 8
     *
     * 那么整个解决流程就变成了 0 3 6 7 8 4这个顺序。然后发现4不对的时候。。我们得擦按照 8 7 6 3 0这个顺序挨个擦去然后填新的。。。
     * 然而4并不知道自己是从8来的。。4只知道自己是从3来的。。那么4就只会告诉3。。我这不行了。。你改改吧。。然后也就只有3开始改了。。
     * 3如果不对。。就告诉0我这没东西填了，0就开始改了。
     * 6 7 8这3个直接全被跳过了。。因为他们后续的终止条件就永远是true了。。。不会有变动了。。。
     *
     * 所以看下面的dfs。。。 j == 9 return dfs(board, i + 1, 0);
     * 这句话就相当于是把整个路径联系起来了。从0 - 1 - 2 - 3
     * 如果不加这个话而是直接return true。。。那么也没了。。走完第一行就结束了。。。
     *
     *
     * 所以不是说走双向不能走。。只要能维护好整条回溯的路径，几个方向都行。。乱七八糟拐来拐去都随便你。。
     * 但是单向走不是好维护么。。像上面那种。。那维护的。。走完8 走4。。。。这鬼才能知道。。走完5再走1啥的。。23333
     *
     *
     * 所以综上所述。。。是在对回溯问题的一个理解上的偏颇。。 回溯一定要注意得能回来。。
     * 其实就是单向啦。。双向就回不来了。。说那么多都是屁话。。。
     *
     * 所以目前为止。。回溯 =》》 单向。。就能回来了。。23333。比如那个用数字产生字符串的。。就是用一个一个数字开始 单向处理到下一个。。下一个处理完回来这边再换一个。。
     * 这就是比较标准的回溯。。
     * 其实到数独这边把9行归约到一行就是。我们怎么填满一行？？肯定一个一个往右填。实在不行再回来。。
     * 扩展到9行就是。填满一行。怎么到下一行？？这一行的结尾怎么直到我到下一行了？？下一行如果不对怎么告诉这一行？？
     * 那么就来了 j == 9 这个判断了。。
     *
     * 说了这么多。。还是回溯的少。。。23333。回溯也是递归。。但是就是单程递归 + 剪枝了。。。
     * 不过这么说 还是自己这个题的问题。。
     * 好好一步一步走不行么。。非要跳。。诶西。。脑子还混乱了 很气。。
     */
    bool dfs(vector<vector<char>>& board, int i, int j) {
        if (i == 9) return true;
        if (j == 9) return dfs(board, i + 1, 0);
        if (board[i][j] != '.') {
            return dfs(board, i, j + 1);
        }
        else {
            int square_idx = i / 3 * 3 + j / 3;
            for (int k = 0; k < 9; k++) {
                if (!row[i][k] && !col[j][k] && !square[square_idx][k]) {
                    row[i][k] = col[j][k] = square[square_idx][k] = true;
                    board[i][j] = '1' + k;
                    if (dfs(board, i, j + 1)) {
                        return true;
                    }
                    row[i][k] = col[j][k] = square[square_idx][k] = false;
                    board[i][j] = '.';
                }
            }
        }
        return false;
    }


private:
    bool row[9][9] = {false}, col[9][9] = {false}, square[9][9] = {false};
    // 我TMD怎么可以忘记初始化这个检查表。。。给那做了半天 干啊。。。。。。好蠢啊。。。。。
    void init_check(vector<vector<char>>& board) {
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] != '.') {
                    int square_idx = i / 3 * 3 + j / 3;
                    int idx = board[i][j] - '1';
                    row[i][idx] = true;
                    col[j][idx] = true;
                    square[square_idx][idx] = true;
                }
            }
        }
    }
};