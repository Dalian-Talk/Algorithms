class Solution {
public:
    /*
     * 贪心(又好像是DP。。。因为用了之前的结果，感觉好像是DP。。。因为就算是个负数我也选了。。)。
     * 一直加下去。只要加上当前这个数比0大。就行。。就意味着前面到这里的和是大于0的。
     * 那么把当前这个大于0的和后续的合在一起就能更大了
     * 然后发生错误了。。毕竟结果可以是负数。。。再想想
     * 
     * 确认了就是DP
     * 当走到某个数的时候，是否要把这个数加进去，是要看加上这个数后，当前的结果能不能比这个数大。因为
     * 1、如果这个数是正数，那么加上这个数比当前数大，那没问题。如果小的话那就代表前面是个负数，那就从这个数开始
     * 2、如果这个数是负数，那么加上这个数能比当前数大，没问题，前面是个正数。如果前面是个负数，那就更没必要把前面带上了。从这个数开始就行了。
     * 反正就正的越多越好。。负的越少越好。
     *
     */

    /*
     * 注释的部分是DP，就是到一个数的时候，是否要选择它。
     *
     * 不注释的部分。。也算DP把。
     * 就是看到目前为止前面能够加起来的部分(如果负的话会被舍弃掉，所以是能够加起来的部分)
     * 是正数的话，就把当前这个数带上，然后算，不管当前正负。因为
     * 1、前面加起来的部分是正的，那刚好，让我当前变大，无论正负
     * 2、前面加起来的部分是负的，那也好，前面的不要了，他只会让我当前变小，所以就从当前的数往后就行了。
     */
    int maxSubArray(vector<int>& nums) {
        int res = INT_MIN;
        int cur = 0;
        for (int num: nums) {
            // if (cur + num > num) {
            //     cur += num;
            // }
            // else {
            //     cur = num;
            // }
            if (cur >= 0) {
                cur += num;
            }
            else {
                cur = num;
            }
            res = max(res, cur);
        }
        return res;
    }
};