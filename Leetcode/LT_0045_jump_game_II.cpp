#include <iostream>
#include <vector>

using namespace std;


class Solution {
public:
    /*
     * 开始想用很简单的方式更新。。。现在发现。。条件看错了。。每个数字代表。。最大往后跳几格。。不是一定跳这么多格的。。
     * 所以下下面这个是错的
     */
    int jump(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n, INT_MAX);
        res[0] = 0;
        for (int i = 0; i < n - 1; i++) {
            // 用一步走的下一个地方更新一下
            res[i + 1] = min(res[i + 1], res[i] + 1);

            // 用当前数字的步数走的地方更新一下
            if (i + nums[i] < n) {
                res[i + nums[i]] = min(res[i + nums[i]], res[i] + 1);
            }
        }
        return res[n - 1];
    }

    /*
     * 其实有了上面的错误判断后，就很明显一个问题来了。。。
     * 上面是必须走那么远，还得处理。
     * 那如果是有选择的话。那当然选能走最远的方式了啊。
     * 比如
     * 3 5 1 1 1 2 3 4 5 6
     * 我们在第一个位置的3。能走到 5 1 1 三个位置。明显就知道。。肯定走到5啊。。因为5下次可以走到3啊。。然后3就能走到6了。多快。。
     * 这其实就是贪心的一种。就是局部下。我们发现对于3，我们能走 5 1 1这三种。然后最快的方式就是从3 走一步到 5
     *
     * 所以这种做法就是在3，然后找后面能跑最远的那个。。走到那个位置就行。。
     * 这里就是3 - 5， 5 - 3， 3 - 6就到了。
     * 这个做法就不写了。。比较基础。。还得加好多判断。。懒。。
     * 。。。想了一下还是写了把。。毕竟是自己的思路。。实现出来也熟练点。。
     */
    /*
     * 写了一下，很简单就能实现了。。。
     */
    int jump(vector<int>& nums) {
        int n = nums.size();
        int idx = 0;
        int jumps = 0;
        while (idx < n - 1) {
            int cur_max = 0;
            int cur_max_idx = idx;

            for (int i = 1; i <= nums[idx]; i++) {
                if (idx + i == n - 1) {
                    return jumps + 1; //因为循环不到最后一个位置。。但是最终要跳出这一步的。。所以就加1了。
                }
                if (nums[idx + i] + idx + i > cur_max) {
                    cur_max = nums[idx + i] + idx + i;
                    cur_max_idx = idx + i;
                }
            }
            jumps++;
            idx = cur_max_idx;
        }
        return jumps;
    }
    /*
     * 然后就是答案那种greedy了。。牛皮的不行。。
     *
     * 思路写在这里，用solution的例子。。
     * 首先。。。我懒得证明。。我也不会。。别人证明过了。。他牛皮。。。
     *
     * 3 5 2 1 4 6 2 ........
     *
     * 1、首先，从人为的思路过去。3 -> 5 -> 6。这样子就能最大化。这就是上面那个算法的思路。是没错的。
     * 2、但是如何节省事件和步骤呢？？答案是这么来greedy的。
     * 3、首先从3出发。我们能去 5 2 1三个位置。也就是说从3这个位置。我们知道了。最远能到0 + 3 = 3这个位置。这一步是必须走出去的。但是走到哪里并不知道。
     * 4、不过这并不重要，我们的目的就是在未来3次循环中，走出那一步，那很明显了，什么时候走出去？？
     * 5、就是在第三步也就是当循环到index = 3的时候走出去也就是好像走到了3这个位置一样。当然在index =3 走出去是不对的，我们要走到的是index = 1也就是5这个位置。
     * 6、所以这里计数，只是通过greedy去记录一个最远能到达的位置，最少步骤走出去而已。跟上面的方法区别就在于。
     * 7、上面是一定要知道走到哪个位置，下面这个就是，走到哪不重要。我只知道我要走多少就行了。
     *
     * 然后开始说流程
     * 1、从3 走 5 2 1，我们有3个选择，idx循环有 1 2 3。 当idx == 3的时候，我们就要跳出这一步了，啥意思？
     * 2、因为从3出发我们最多有3个选择。当idx == 3的时候意味着我们这三个已经处理完了。。我们要跳出去了。。
     * 3、那么下一次在哪里跳出去？？
     * 4、从例子看出来。我们要从5跳到6。这个抉择如何在这个代码中体现？
     * 5、idx == 1我们直到这个时候，最远下次可以到1 + 5 = 6这个位置了
     * 6、对于之后的2 1，都比前面的5短。
     * 7、所以这三步我们才知道，从5是可以跳最远的，下次就是要从5往后进行5次抉择，看又要怎么选最远的地方。然后下次我们就知道。到idx = 6的时候就一定要再多一跳了。
     * 8、因为对于5来说，就5中选择。最远到idx == 6，所以到了6就得跳出去了，中间的该更新的部分都更新完了。
     *
     *
     * 所以综上。这个greedy的思路就是。把上面的方法做了一个简化。我们不在意每次从哪里跳。我们只在意什么时候该跳了。然后这个该跳的判断，
     * 会在过程中把当前最远的给更新出来。这样子就保证跳的是最远的，并且省略了算的步骤。
     * 从上面的例子，我们 5 2 1算完后，之后其实是针对5腰酸 2 1 4 6 2。然后我们发现2 1 都算过了。只要算4 6 2就行了。
     * 当然这些是隐含在整个算法中的。。实际过程看不到这些判断，过程中都隐含的包含进去了。。
     * 所以上面那个方法好理解，下面这个方法快、牛皮。
     *
     *
     */
    int jump(vector<int>& nums) {
        int n = nums.size();
        if (n == 1) {
            return 0;
        }
        int farthest = nums[0];
        int current_end = nums[0];
        //本来想最后一步跳不出去，循环不循环最后一个位置，所以这里从1开始。
        //但是单独一个就得再处理一下，，毕竟solution那种从0开始我无法理解。。我要写自己懂的。。
        //TM本来说不想单独处理。。结果要写的地方多了那么多。。还是单独处理吧。。
        int jumps = 1;
        for (int i = 1; i < n - 1; i++) {
            farthest = max(farthest, nums[i] + i); //每一步都看看以后最远应该去哪里才要决定跳那一步。
            if (i == current_end) {
                current_end = farthest;
                jumps++;
            }
        }
        return jumps;
    }

};