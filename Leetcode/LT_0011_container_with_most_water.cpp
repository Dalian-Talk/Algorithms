#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:

    /*
     * 这边感觉是个贪心？？还是一个数学规律？？
     * container中的水量计算是 S = H * L
     * 其中H是两根柱子中小的那个，L就是两个柱子中间的间隔。(逻辑上怪怪的。。柱子不算宽度呗？？23333)
     *
     * 暴力算法当然是，把所有的柱对都拿出来。算一下就ok了 O(n^2)
     * 简化后就是O(n)了。走一遍就行。。
     * 怎么想到走一遍？？
     * 1、首先，当数组给定后，最大的L一下就知道了。。就那么多根柱子不是。那么我们第一点肯定是要看一下这个最大的L对应的面积是否是最大的咯。
     * 2、在看完最大的L对应的面积后，很容易就想到。。如果这个状态下两边的柱子有一个特别短就明显没啥用了。。毕竟 1 * 5 不如100 * 1 咯
     * 3、所以要缩减这个L往中间找。。
     * 最开始其实就是卡在了如何往中间找这个问题。
     *
     * 举个例子现在是
     * 2,1,3,18,17,6 目前在2和6
     * 那么很明显，2太小了。。很容易被中间的 18 17的结果给比过去。所以要缩减L往中间。
     * 缩谁？？
     * 1、缩6？。明显不应该，因为6比2更高，在未来可能做出的贡献更多。。
     * 2、缩2？。感觉上是的，因为2太小了，如果往中间找到一个比2大的，说不定在 H' * L' 能比之前的 H * L 大
     * 3、一起缩？这个就是我之前的想法问题。。为啥要一起缩。。当时脑子就抽了。。这一起缩不就直接把 L - 2了？？直接就少了当2增加后与6这个柱子中间的水量了。。
     * 说实话。。。。我不知道为啥那一瞬间会这么想，。估计是two pointers 做习惯了。。总想两个一起动。。哎。。。有点呆啊。。。
     *
     * 所以最后我们发现，要缩的是两根柱子中小的那个。。毕竟提升小的才有可能获取更多水。。提升大的没用不是。。。
     *
     */

    int maxArea(vector<int> &height) {

    }
};



int main() {
    return 0;
}